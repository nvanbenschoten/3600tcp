   __      ____     __      __   __                     
 /'__`\   /'___\  /'__`\  /'__`\/\ \__                  
/\_\L\ \ /\ \__/ /\ \/\ \/\ \/\ \ \ ,_\   ___   _____   
\/_/_\_<_\ \  _``\ \ \ \ \ \ \ \ \ \ \/  /'___\/\ '__`\ 
  /\ \L\ \\ \ \L\ \ \ \_\ \ \ \_\ \ \ \_/\ \__/\ \ \L\ \
  \ \____/ \ \____/\ \____/\ \____/\ \__\ \____\\ \ ,__/
   \/___/   \/___/  \/___/  \/___/  \/__/\/____/ \ \ \/ 
                                                  \ \_\ 
                                                   \/_/ 
--- Team America ---

Nathaniel Dempkowski and Nathan VanBenschoten

----------------------
High Level Approach
----------------------

To approach this project, we broke the problem into parts: a sender who creates packets, determines how much data to send at once, and delivers the data, and the receiver who takes in data as packets and returns acknowledgment packets. Like TCP, we decided upon the model of making our sender as smart and effective as possible, while generalizing the job of the receiver and making its job easy and quick.

For the sender we have a loop that runs until we have sent and acknowledged all of our data. This loop consists of three phases, creating packets to send, sending packets, and receiving acknowledgements. We first create packets until we fill up our window or run out of data to send. Next we send all of the packets as necessary, either sending all of the available packets in the window, or just sending one in the event of a fast retransmit. Finally we wait for received acknowledgements and process those, making adjustments to our window, timeout, and phase as necessary. We also do things like fast retransmit in response to these ACKs, which are discussed in greated detail below. In the event of a timeout we further adjust our window size and timeout. After receiving all of the ACKS for the data packets, we send the final EOF packet, which indicates that no more data will be sent, 3 times to easily ensure that it is not dropped/lost.

For the receiver, 

- Helper functions 

-- Generic (3600sendrecv.c)

get_checksum
Takes in a header, a pakcets data, and the length of the header, and returns the checksum that the packet should have. This is used to both create the checksum beofre sending a pakcet and validate a packet after it has been received. The checksum works by taking the 1's compliment of the header and the data (but not the checksum) and 

dump_packet

make_header

get_header

get_data

timestamp

mylog

-- Sender Specific (3600send.c)

usage
Prints command-line usage information for the 3600send program.

get_next_data
Reads the next block of data from STDIN of a certain size.

get_next_packet
Builds and returns the next packet in the sequence if there is more data to create packets for. This first creates a header for the packet, including information like the sequence number, length, and time. It then inserts the checksum in the packet, which is a checksum of both the header and the data combined. The data is then inserted into the packet, and a pointer to the packet is returned.

get_final_packet
Builds and returns the final packet that indicates all data has been sent. This is packet is essentially just a header with the EOF flag set and a checksum of the header attached.

update_timeouts
Updates the timeout values for waiting for acknowledgements for sent data packets. This keeps a moving exponential average of the RTT for a data packet and its acknowledgement in microseconds. This time is measured with the time field in the header, which is the time the packet was sent as the number of microseconds since the program started creating and sending packets. We used this because it provided a high degree of accuracy and was easily convertible into seconds and microseconds which our timeout timeval structure used.

----------------------
 Challenges Faced
----------------------



----------------------
 Properties/Features
----------------------

We use a variable window and timeout in our protocol to try and avoid/detect problems efficiently. We use a moving exponential average of the round-trip times of each successful data packet to try and keep our timeout as accurate as possible.

Slow Start and Congestion Avoidance

Our transport protocol has two phases of transmission to try and make as efficient use of the network as possible. In the first phase, Slow Start, we quickly scale up our window size to try and grow to accomodate many different scales of networks quickly. To do this we increase our window size by 1 for every ACK we get back during this phase. This causes the window size to double for every successful round, scaling up very quickly. This phase completes upon receiving a duplicate ACK or timing out waiting for ACKs. This generally would indicate that some sort of problem or congestion has been hit, and that we should stop scaling up as quickly. We then cut our window size in half and move to the congestion avoidance phase. In that phase we increase our window by a small number dependent on the success of the previous round. Currently we use 1 per entirely successful round, but this can be changed. If timeouts occur we then scale back down the window size.

Fast Retransmit

Upon receiving a few duplicate ACKs (currently 5) we immediately resend the packet the ACKs are looking for and go back to receiving ACKs again. This hopefully helps to quickly resend dropped or corrupted packets as we assume that most packets in our networks will be okay.

Checksum

----------------------
 Testing Procedure
----------------------

We based our testing on the provided test, as well as using the debug functions like dump_packet and 'print log' to make sure we were always sending and interpreting packets correctly and efficiently. During these tests we heavily used GDB to debug edge cases that we thought of and saw. Additionally, we made a few smaller testing programs to verify that our helper functions functioned correctly in all cases, allowing us to pinpoint errors that may have gone undetected otherwise. Throughout development we also modified the provided test to allow us to automatically test various specific cases. Additionally, we integrated git into our workflow as it provided a convenient tool for our workflow. In total we had ~40 commits. 

----------------------
 Bald Eagle
----------------------

                               /T /I
                              / |/ | .-~/
                          T\ Y  I  |/  /  _
         /T               | \I  |  I  Y.-~/
        I l   /I       T\ |  |  l  |  T  /
     T\ |  \ Y l  /T   | \I  l   \ `  l Y
 __  | \l   \l  \I l __l  l   \   `  _. |
 \ ~-l  `\   `\  \  \\ ~\  \   `. .-~   |
  \   ~-. "-.  `  \  ^._ ^. "-.  /  \   |
.--~-._  ~-  `  _  ~-_.-"-." ._ /._ ." ./
 >--.  ~-.   ._  ~>-"    "\\   7   7   ]
^.___~"--._    ~-{  .-~ .  `\ Y . /    |
 <__ ~"-.  ~       /_/   \   \I  Y   : |
   ^-.__           ~(_/   \   >._:   | l______
       ^--.,___.-~"  /_/   !  `-.~"--l_ /     ~"-.
              (_/ .  ~(   /'     "~"--,Y   -=b-. _)
               (_/ .  \  :           / l      c"~o \
                \ /    `.    .     .^   \_.-~"~--.  )
                 (_/ .   `  /     /       !       )/
                  / / _.   '.   .':      /        '
                  ~(_/ .   /    _  `  .-<_
                    /_/ . ' .-~" `.  / \  \          ,z=.
                    ~( /   '  :   | K   "-.~-.______//
                      "-,.    l   I/ \_    __{--->._(==.
                       //(     \  <    ~"~"     //
                      /' /\     \  \     ,v=.  ((
                    .^. / /\     "  }__ //===-  `
                   / / ' '  "-.,__ {---(==-
                 .^ '       :  T  ~"   ll      
                / .  .  . : | :!        \\			- Team America
               (_/  /   | | j-"          ~^
                 ~-<_(_.^-~"

			(Shamelessly stolen from the internet)
